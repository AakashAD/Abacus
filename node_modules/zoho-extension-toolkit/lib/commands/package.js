/*
Copyright (c) 2017, ZOHO CORPORATION
License: MIT
*/

var archiver = require('archiver');
var chalk = require('chalk');
var { existsSync, ensureFileSync, createWriteStream } = require('fs-extra');
var path = require('path');
var i18next = require('i18next');
var fileTreeParser = require('../utils/file-tree-parser.js');
var service = require('./../utils/service.js');
var CONST = require('./constants.js');

function bundleFiles(projectContext, archiveStream, fileTree, outputStream) {
  return new Promise(function (resolve) {
    //add files to be zipped
    for (var key in fileTree) {

      if (['projectRoot', 'appBase', 'misc'].indexOf(key) !== -1) continue;

      var assets = fileTree[key];
      for (var i = 0; i < assets.length; i++) {
        var filePath = path.join(fileTree.projectRoot, assets[i]);
        archiveStream.file(filePath, { name: assets[i] });
      }
    }

    var serviceName = service.getServiceName(projectContext);
    if (serviceName !== CONST.SERVICE.CRM) {
      archiveStream.file(path.join(projectContext, CONST.PLUGIN_MANIFEST), { name: CONST.PLUGIN_MANIFEST });
    }
    if( serviceName === CONST.SERVICE.DESK) {
      var resourceJSONPath = path.join(projectContext, CONST.RESOURCE_JSON);
      if( existsSync(resourceJSONPath) ) {
        archiveStream.file(resourceJSONPath, { name: CONST.RESOURCE_JSON });
      }
    }

    archiveStream.finalize();
    outputStream.on('close', function () {
      resolve();
    });
  });
}

function runRule(ruleName, projectContext) {
 
  if (ruleName !== undefined) {
    var ruleFullPath = path.join(__dirname, '../rules', ruleName);
    if (existsSync(ruleFullPath)) {
      return require(ruleFullPath).run(projectContext);
    }
  }
  return Promise.resolve();
}

module.exports = {

  run: function (projectRootDir) {
      var archive = archiver('zip');
      var serviceName = service.getServiceName(projectRootDir);
      var ruleConfig = service.getValidationRules(projectRootDir);

      require('./validate').run(projectRootDir, ruleConfig.PRE_RULES);

      var archivePath = path.join(projectRootDir, '/dist/', path.basename(projectRootDir) + '.zip');
      ensureFileSync(archivePath);
      var outputStream = createWriteStream(archivePath);
      archive.pipe(outputStream);


      var prePackRule = service.getPrePackRule(projectRootDir);
      var postPackRule = service.getPostPackRule(projectRootDir);

      console.log(chalk.bold.cyan(i18next.t('pacakage_prj')));

      runRule(prePackRule, projectRootDir).then(() => {
        var fileTree = fileTreeParser.parse(projectRootDir, serviceName);
        return bundleFiles(projectRootDir, archive, fileTree, outputStream);
      }).then(() => {
        return runRule(postPackRule, projectRootDir);
      }).then(() => {
        console.log(chalk.bold.green(i18next.t('package_sucess') + path.basename(archivePath) + i18next.t('package_in_folder')));
      }).catch((error) => {
        console.log("Packaging Error", error);
      });
  }
  
};
