'use strict';

const axios = require('axios');
const _ = require('../util_modules');
var fs = require('fs');
var path = require('path');

class API {
	constructor({
		auth = true,
		resolveOnHTTPError = false,
		maxRetry = 3,
		env = 'Development',
		log = {}
	} = {}) {
		this.requestOpts = {
			method: 'GET',
			headers: {}
		};
		this.authNeeded = auth;
		this.resolveOnHTTPError = resolveOnHTTPError;
		this.logOpts = log;
		this.maxRetryCount = maxRetry;
		this.retryCount = 0;
		this.progress = null;
		this.downloadfile = false;
		this.zipPath = null;
		this.startTime = null;
	}

	_logReq() {
		let params = this.requestOpts.params
			? '\nQuery params: ' + JSON.stringify(this.requestOpts.params)
			: '';
		params = this.logOpts.skipQuery === true ? '\n<request query omitted>' : params;

		let body = this.requestOpts.data
			? '\nRequest Body: ' + JSON.stringify(this.requestOpts.data)
			: '';
		body = this.logOpts.skipReqBody === true ? '\n<request body omitted>' : body;

		_.LOGGER.debug(
			'>>>> HTTP REQUEST : ' +
				this.requestOpts.method +
				' ' +
				this.requestOpts.url +
				' ' +
				params +
				body +
				'\n'
		);
	}

	_logResp(resp) {
		const endTime = Date.now();
		const totalTime = this.startTime ? endTime - this.startTime : 0;
		_.LOGGER.debug(
			'<<<< HTTP RESPONSE : ' +
				resp.status +
				'\n' +
				'Response Headers' +
				JSON.stringify(resp.headers) +
				'\n'
		);

		if (totalTime > 0) {
			_.LOGGER.debug('TOTAL TIME TAKEN : ' + totalTime + ' ms\n');
		}
	}

	_addAuthHeader() {
		return require('./credential')
			.getAccessToken()
			.then((access_token) => {
				_.JS.set(this.requestOpts, 'headers.authorization', 'Bearer ' + access_token);
			});
	}

	_parseResponse(resp) {
		if (resp.status >= 400 && !this.logOpts.skipRespBody) {
			_.LOGGER.debug('Response Body : ' + JSON.stringify(resp.data) + '\n');
			if (!this.resolveOnHTTPError) {
				return Promise.reject(require('../errorResponse')(resp, resp.data));
			}
		}

		return Promise.resolve({
			status: resp.status,
			response: resp,
			body: resp.data
		});
	}

	_retry(err) {
		if (++this.retryCount > this.maxRetryCount) {
			return _.PROMISE.reject('API Error after retrying : ' + err.message, {
				original: err,
				exit: 2
			});
		}
		_.LOGGER.debug('API Error while firing request : ' + err.message + '\n');
		_.LOGGER.debug('>>>> RETRYING\n');
		return this._request(true);
	}

	async _request(retry = false) {
		if (!retry){
			this._logReq();
		}
		this.startTime = Date.now();

		if (this.downloadfile){
			this.requestOpts.responseType = 'stream';
		} 

		try {
			const response = await axios(this.requestOpts);
			this._logResp(response);

			if (this.downloadfile) {
			const writer = fs.createWriteStream(path.join(this.zipPath, 'app_file.zip'));
			response.data.pipe(writer);

			return new Promise((resolve, reject) => {
				writer.on('finish', () => {
				_.LOGGER.debug('Zip file is downloaded');
				resolve();
				});
				writer.on('error', (err) => reject(err));
			});
			}

			return await this._parseResponse(response);
		} catch (err) {
			switch (err.code) {
			case 'ETIMEDOUT':
			case 'ENOTFOUND':
			case 'ESOCKETTIMEDOUT':
				_.LOGGER.warning(
				err.code + ' has occured while communicating remote server. Kindly be patient while the cli retries this request.'
				);
				return this._retry(err);

			default:
				_.LOGGER.error('API Error. ' + err.message);
				process.exit(1);
			}
		}
	}


	fire(method, path, options) {
		let dctype = _.JS.get(options,'dctype');
		let origin = this.urlDcEncoder(_.JS.get(options, 'origin'),dctype);
		this.resolveOnHTTPError = _.JS.get(options, 'resolveOnError', this.resolveOnHTTPError);
		this.maxRetryCount = _.JS.get(options, 'maxRetry', this.maxRetryCount);
		this.authNeeded = _.JS.get(options, 'auth', this.authNeeded);
		this.logOpts = _.JS.get(options, 'log', this.logOpts);
		this.downloadfile = _.JS.get(options, 'downloadfile', this.downloadfile);
		this.zipPath = _.JS.get(options, 'zipPath', this.zipPath);
		this.requestOpts = _.JS.defaults(
			_.JS.omit(options, ['origin', 'auth', 'maxRetry', 'resolveOnError', 'log', 'dctype', 'json']),
			this.requestOpts
		);
		this.requestOpts.url = origin + path;
		this.requestOpts.method = method;

		if (this.authNeeded) {
			return this._addAuthHeader().then(() => {
				return this._request();
			});
		}
		return this._request();
	}

	get(path, options) {
		return this.fire('GET', path, options);
	}

	put(path, options) {
		return this.fire('PUT', path, options);
	}

	post(path, options) {
		return this.fire('POST', path, options);
	}

	delete(path, options) {
		return this.fire('DELETE', path, options);
	}
	urlDcEncoder(url,dctype){
		if(dctype){
			if(_.CONSTANTS.DCTYPES[dctype]){
				return url.replace('dctype',_.CONSTANTS.DCTYPES[dctype]);
			}else{
				_.LOGGER.debug("Invalid DC type so using US dc");
				return url.replace('dctype',_.CONSTANTS.DCTYPES["us"]);
			}
		}else{
			_.LOGGER.error('DC Information is not found.Kindly re-login using zet login --force');
		}
	}
}

module.exports = API;