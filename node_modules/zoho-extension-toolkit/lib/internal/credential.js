'use strict';

const font = require('ansi-colors');

const _ = require('../util_modules');
const conf = require('../configstore');
const API = require('./api');
const crypt = new (require('./crypt'))('ZC_TRAM');


class Credential {
	constructor(tokenObj) {
		this.cToken = tokenObj.token;
		this.cTime = tokenObj.created_time; // this may be undefined

		if (_.JS.isEmpty(this.cToken) || this.cToken.slice(1, 2) !== '_') {
			_.LOGGER.error(
				'Invalid token passed for authentication. If you havent used --token option. kindly relogin with ' +
					font.bold('zet login --force')
			);
			process.exit(1);
		}
		this.salt = this.cToken.slice(0, 1);
		this.rToken = this.cToken.slice(2);
		this.client = this._getClientForSalt(this.salt);
		this.maxExpiry = 10 * 60 * 1000; // 10 min in ms
		this.breaktime = 2 * 60 * 1000; //5 min in ms
	}

	_getClientForSalt(salt) {
		switch (salt) {
			case 'w':
				return _.CONSTANTS.AUTH.web;
			case 'm':
				return _.CONSTANTS.AUTH.mobile;
			default:
				return null;
		}
	}

	_getTokenObjFromStore(pth = 'credential') {
		let encryptedToken = conf.get(pth, null);
		if (_.JS.isNull(encryptedToken)) {
			return null;
		}
		let tokenObj = crypt.decrypt(encryptedToken);
		let confCredential = new Credential(tokenObj);
		if (this.rToken === confCredential.rToken) {
			return tokenObj;
		}
		return null;
	}

	_setTokenObjToStore(pth) {
		let encryptObj = crypt.encrypt(Credential._tokenObj);
		conf.set(pth, encryptObj);
	}

	_getAccessTokenFromCache() {
		if (_.JS.isEmpty(Credential._tokenObj)) {
			let tokenObj = this._getTokenObjFromStore();
			tokenObj =
				tokenObj === null && Credential._temp
					? this._getTokenObjFromStore('__temp.credential')
					: tokenObj;
			if (_.JS.isNull(tokenObj)) {
				return null;
			}
			Credential._tokenObj = tokenObj;
		}
		if (
			_.JS.has(Credential._tokenObj, 'access_token') &&
			Credential._tokenObj.refresh_token === this.rToken &&
			_.JS.has(Credential._tokenObj, 'expires_at') &&
			Credential._tokenObj.expires_at > (Date.now() + this.breaktime) 
		) {
			return Credential._tokenObj.access_token;
		}
		return null;
	}

	_rebuildTokenCache(res) {
		Credential._tokenObj = _.JS.assign(
			{
				created_time: this.cTime || Date.now(),
				expires_at: (Date.now() + (res.body.expires_in * 1000)),
				refresh_token: this.rToken
			},
			res.body
		);
		Credential._tokenObj.token = this.salt + '_' + Credential._tokenObj.refresh_token;
		if (Credential._temp) {
			this._setTokenObjToStore('__temp.credential');
		} else {
			this._setTokenObjToStore('credential');
		}
	}

	_destroyTokenObjFromStore(pth = 'credential') {
		conf.delete(pth);
		if (pth === 'credential') {
			conf.delete('usage');
			conf.delete('user');
			conf.delete('scopes');
			conf.delete('dctype');
			conf.delete('default_workspace');
			conf.delete('oAuthCreatedTime');
		}
	}

	refreshAccessToken() {
		_.LOGGER.debug('> refreshing access token <');
		let self = this;
		return new API({ auth: false })
			.post('/oauth/v2/token', {
				origin: _.CONSTANTS.ORIGIN.auth,
				dctype: conf.get('dctype'),
				params: {
					refresh_token: this.rToken,
					client_id: this.client.id,
					client_secret: this.client.secret,
					grant_type: 'refresh_token'
				},
				log: {
					skipQuery : true 
				}
			})
			.then((res) => {
				if (!_.JS.isString(res.body.access_token)) {
					_.LOGGER.error(
						'unable to refresh access token. Kindly use ' +
							font.bold('zet login --force') +
							'to re-authenticate.'
					);
					process.exit(1);
				}
				self._rebuildTokenCache(res);
				return Credential._tokenObj;
			});
	}

	persistMinimal(pth) {
		Credential._tokenObj = {
			created_time: Date.now(),
			expires_at: Date.now() + this.maxExpiry,
			refresh_token: this.rToken
		};
		_.JS.set(
			Credential._tokenObj,
			'token',
			this.salt + '_' + Credential._tokenObj.refresh_token
		);
		this._setTokenObjToStore(pth);
		Credential._tokenObj = {};
		//console.log(Credential._self);
	}

	reset(pth) {
		this._destroyTokenObjFromStore(pth);
		Credential._temp = false;
		Credential._tokenObj = {};
		Credential._self = null;
		Credential._oneTimeToken = null;
	}

	get accessToken() {
		return this._getAccessTokenFromCache();
	}

	get accessTokenPromise() {
		return Promise.resolve(this.accessToken);
	}

	get refreshToken() {
		return this.rToken;
	}

	get cliToken() {
		return this.cToken;
	}

	get createdTime() {
		return this.cTime;
	}

	static oneTimeToken(accessToken) {
		Credential._oneTimeToken = accessToken;
	}

	static init(token, temp = false) {
		token = crypt.isEncrypted(token) ? crypt.decrypt(token) : token;
		if (_.JS.isString(token)) {
			token = { token };
		}
		Credential._self = new Credential(token);
		Credential._temp = temp;
		return Credential._self;
	}

	static getAccessToken() {
		if (_.JS.isNull(Credential._self)) {
			if (_.JS.isNull(Credential._oneTimeToken)) {
				_.LOGGER.error(
					'Authentication required, kindly login with ' + font.bold('ZET login')
				);
				process.exit(1);
			}
			return Promise.resolve(Credential._oneTimeToken);
		}
		return Credential._self.accessTokenPromise.then((accessToken) => {
			if (_.JS.isNull(accessToken)) {
				return Credential._self.refreshAccessToken().then((tokenObj) => {
					return tokenObj.access_token;
				});
			}
			return accessToken;
		});
	}
}
Credential._tokenObj = {};
Credential._self = null;
Credential._temp = false;
Credential._oneTimeToken = null;
module.exports = Credential;
