'use strict';

const crypto = require('crypto');

class Crypt {
	constructor(password) {
		this.encryptionKey = password;
		this.cryptAlgo = 'aes-256-cbc';
	}

	decrypt(value) {
		let data = Buffer.from(value, 'hex');
		// Check if an initialization vector has been used to encrypt the data
		if (data.slice(16, 17).toString() !== ':') {
			return null;
		}
		const initializationVector = data.slice(0, 16);
		const password = crypto.pbkdf2Sync(
			this.encryptionKey,
			initializationVector.toString(),
			1000,
			32,
			'sha512'
		);
		const decipher = crypto.createDecipheriv(this.cryptAlgo, password, initializationVector);
		data = Buffer.concat([decipher.update(data.slice(17)), decipher.final()]);
		return this._deserialize(data);
	}

	encrypt(value) {
		let data = this._serialize(value);
		const initializationVector = crypto.randomBytes(16);
		const password = crypto.pbkdf2Sync(
			this.encryptionKey,
			initializationVector.toString(),
			1000,
			32,
			'sha512'
		);
		const cipher = crypto.createCipheriv(this.cryptAlgo, password, initializationVector);
		data = Buffer.concat([
			initializationVector,
			Buffer.from(':'),
			cipher.update(Buffer.from(data)),
			cipher.final()
		]);
		return data.toString('hex');
	}

	isEncrypted(value) {
		try {
			let data = Buffer.from(value, 'hex');
			// Check if an initialization vector has been used to encrypt the data
			if (data.slice(16, 17).toString() === ':') {
				return true;
			}
		} catch (err) {
			return false;
		}
		return false;
	}

	_serialize(value) {
		return JSON.stringify(value, null, '');
	}

	_deserialize(value) {
		return JSON.parse(value);
	}
}

module.exports = Crypt;
