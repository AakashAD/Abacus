'use strict';

const fs = require('fs-promise');
const os = require('os');
const path = require('path');
const minimatch = require('minimatch');

module.exports = {
	dirExists: async (pth) => {
		let stats = await fs.stat(pth).catch(() => false);
		return stats && stats.isDirectory();
	},

	fileExists: async (pth) => {
		let stats = await fs.stat(pth).catch(() => false);
		return stats && stats.isFile();
	},

	readFile: async (pth, encoding = 'utf8') => {
		if (await module.exports.fileExists(pth)) {
			return fs.readFile(pth, encoding);
		}
		return null;
	},

	tempFile: async (name = Date.now()) => {
		const tempDir = path.join(os.tmpdir(), '.catalyst');
		const tempFile = path.join(tempDir, name);
		await fs.ensureFile(tempFile);
		return tempFile;
	},

	writeFile: async (pth, content, encoding = 'utf8') => {
		return fs.writeFile(pth, content, { encoding });
	},

	dirList: async (dir) => {
		let files = await fs.readdir(dir);
		files = await Promise.all(
			files.map(async (entity) => {
				const entityPath = path.join(dir, entity);
				const stats = await fs.stat(entityPath);
				if (stats.isDirectory()) {
					return entityPath;
				}
			})
		);
		return files.reduce(
			(all, folderContents) => (folderContents ? all.concat(folderContents) : all),
			[]
		);
	},

	walk: async (dir, exclude = []) => {
		const dirStat = await fs.stat(dir);
		let files = dirStat.isDirectory() ? await fs.readdir(dir) : [path.basename(dir)];
		files = await Promise.all(
			files.map(async (file) => {
				const filePath = dirStat.isDirectory() ? path.join(dir, file) : dir;
				let match = false;
				for (let glob of exclude) {
					match = minimatch(filePath, glob);
					if (match) break;
				}
				if (match) return [];
				const stats = await fs.stat(filePath);
				return stats.isDirectory() ? module.exports.walk(filePath, exclude) : filePath;
			})
		);
		return files.reduce((all, folderContents) => all.concat(folderContents), []);
	},

	ensureDir: async (pth) => {
		return fs.ensureDir(pth);
	},

	deleteFile: async (filePath) => {
		return fs.remove(filePath);
	},

	deleteDir: async (dir) => {
		return fs.remove(dir);
	},

	copyFile: async (src, dest) => {
		await module.exports.ensureDir(path.dirname(dest));
		return await fs.copyFile(src, dest);
	},

	copyDir: async (srcDir, destDir, { filter = () => true } = {}) => {
		return fs.copy(srcDir, destDir, { filter });
	},

	rename: async (pth, modifier = (baseName) => baseName) => {
		if (Array.isArray(pth)) {
			return Promise.all(pth.map((el) => module.exports.rename(el, modifier)));
		}

		const parsedPath = path.parse(pth);
		let modifiedName = path.join(parsedPath.dir, modifier(parsedPath.base, parsedPath.ext));
		return fs.rename(pth, modifiedName);
	},

	findAndReplace: (pth) => async (templates, finalWords) => {
		if (Array.isArray(pth)) {
			return Promise.all(
				pth.map((el) => module.exports.findAndReplace(el)(templates, finalWords))
			);
		}
		let files = await module.exports.walk(pth);
		return Promise.all(
			files.map(async (file) => {
				let content = await module.exports.readFile(file);
				if (Array.isArray(templates)) {
					templates.forEach((temp, i) => {
						content = content.replace(new RegExp(temp, 'g'), finalWords[i]);
					});
				} else {
					content = content.replace(new RegExp(templates, 'g'), finalWords);
				}
				return module.exports.writeFile(file, content);
			})
		);
	}
};
